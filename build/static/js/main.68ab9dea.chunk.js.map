{"version":3,"sources":["Pathfinding/Cells/Cell.jsx","Pathfinding/Algorithms/Dijkstra.js","Pathfinding/Algorithms/AStar.js","Pathfinding/Mazes/RecusiveDivision.js","Pathfinding/Mazes/RecursiveDivisionRandomizer.js","Pathfinding/Pathfinding.jsx","Pathfinding/Mazes/Patterns.js","DataStrucutres/Stack/Stack.js","DataStrucutres/Node/Node.jsx","DataStrucutres/DataStructures.jsx","Sorting/Algorithms/MergeSort.js","Sorting/Algorithms/QuickSort.js","Sorting/Sorting.jsx","App.js","serviceWorker.js","index.js"],"names":["Cell","this","props","row","col","startCell","endCell","wall","onMouseDown","onMouseUp","onMouseEnter","classIdentifier","className","id","Component","dijkstra","grid","start","end","visited","length","getStart","distance","unvisited","nodes","cell","push","getAllNodes","sort","a","b","closestCell","shift","Infinity","updateNeighbors","neighbors","filter","neighbor","getNeighbors","previous","getSmallestElementInList","list","lowest","Number","MAX_SAFE_INTEGER","i","f","removeFromList","element","splice","addNeighbors","current","cols","rows","neighborsArray","heuristic","d1","Math","pow","d2","sqrt","recursiveDivisionMaze","height","width","minRows","maxRows","minCols","maxCols","orientation","windowWidth","windowHeight","console","log","possibleWalls","possibleOpenings","randomColumn","floor","random","randomRow","recursiveDivision","recursiveDivisionRandomizerMaze","recursiveDivisionRandomizer","minWidth","maxWidth","minHeight","maxHeight","possibleColumns","openRows","randomColumnIndex","randomRowIndex","selectedColumn","selectedRow","concat","possibleRows","openColumns","Typography","Text","Menu","SubMenu","Layout","Header","Footer","Sider","Content","Pathfinding","handleOk","e","setState","visibelModal","createGrid","state","currentCol","createCell","startRow","startCol","endRow","endCol","createWall","newGrid","slice","getCell","newCell","setWall","walls","x","onCollapse","collapsed","previousStartRow","previousStartCol","previousEndRow","previousEndCol","mouseDown","mouseUp","mouseHold","holdingStart","holdingEnd","activeMaze","activeAlgorithm","pathFound","simulationComplete","selectedAlgorithm","selectedMaze","destroyingWall","bind","document","getElementById","classList","add","remove","updateGrid","buildingWall","mazeWalls","algorithm","shortestPath","pathOrder","currentCell","unshift","getShortestPath","animateDijkstra","open","closed","g","h","curr","ret","parent","reverse","includes","gScore","gScoreIsBest","astar","animateShortestPath","maze","newVisited","drawBorders","smilyFaceMaze","waitTime","animateMaze","setTimeout","undefined","Fragment","title","visible","onOk","onCancel","style","collapsible","theme","defaultSelectedKeys","mode","type","Item","key","onClick","disabled","visualizeAlgorithm","ClearOutlined","handleClearBoard","paddingTop","display","map","rowId","cellId","handleMouseDown","handleMouseEnter","handleMouseUp","getNode","stack","index","Node","letter","currentIndex","stackState","Search","Input","selectedStructure","activeStructure","value","arr","originalString","reversedString","pushedStack","active","string","createDisplay","message","warning","handlePush","newString","substring","newPushed","newReversed","handlePop","val","paddingLeft","indexId","placeholder","enterButton","onSearch","computeEquation","pushIndex","popIndex","clearStack","mergeSortAlgo","array","animations","auxiliaryArray","preMergeSort","mainArray","startIdx","endIdx","middleIdx","k","j","mergeSort","quickSortAlgo","auxArray","quickSort","low","high","pivot","swap","partition","t","Sorting","selectedSort","clearArray","min","max","animateSorting","arrayBars","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","color","backgroundColor","newHeight","computeSort","App","to","ghost","exact","path","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.68ab9dea.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport './Cell.css'\n\nclass Cell extends Component {\n    render() { \n        const { row, col, startCell, endCell, wall, onMouseDown, onMouseUp, onMouseEnter } = this.props;\n        const classIdentifier = endCell ? 'cell-end' : startCell ? 'cell-start' : wall ? 'cell-wall' : '';\n        return ( \n            <div\n                className={`cell ${classIdentifier}`}\n                id={`cell-${row}-${col}`}\n                wall={wall}\n                onMouseDown={() => onMouseDown(col, row)}\n                onMouseEnter={() => onMouseEnter(col, row)}\n                onMouseUp={() => onMouseUp(col, row)}\n            />\n        );\n    }\n}\n \nexport default Cell;","\nexport function dijkstra(grid, start, end){\n    const visited = [];\n    var start = getStart(grid);\n    start.distance = 0;\n    const unvisited = getAllNodes(grid);\n\n    while(!!unvisited.length) {\n        sortCellsByDistance(unvisited);\n        // Sets the closest cell to the first in the array\n        const closestCell = unvisited.shift();\n        \n        // If the current closest cell is a wall, continue\n        if(closestCell.wall === true){\n            continue;\n        }\n\n        // If the current closest cell has a distance of infinity, return the visited cells array, \n        // add it to the visited cells array and set the \"VISITED\" attribute to true\n        if(closestCell.distance === Infinity) {\n            return visited;\n        }\n        closestCell.visited = true;\n        visited.push(closestCell);\n\n        // If the current closest cell is the destination call, return the visited cells array\n        if(closestCell === end) {\n            return visited;\n        };\n        updateNeighbors(closestCell, grid);\n    }\n}\n\n\n// Gets each cell from the 2D grid and stores it (with its props) in an array\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const cell of row) {\n            nodes.push(cell);\n        }\n    }\n    return nodes;\n}\n\n// Sorts the nodes based on the distance between the current node and the next node\nfunction sortCellsByDistance(cells) {\n    cells.sort((a, b) => a.distance - b.distance);\n}\n\n\nfunction updateNeighbors(cell, grid) {\n    const unvisited = getNeighbors(cell, grid);\n    for (const neighbor of unvisited) {\n        neighbor.distance = cell.distance + 1;\n        neighbor.previous = cell;\n    }\n}\n\nfunction getNeighbors(cell, grid) {\n    const neighbors = [];\n    const { col, row } = cell;\n    // Gets the Top Cell\n    if(row > 0)\n        neighbors.push(grid[row - 1][col])\n    // Gets the Bottom Cell\n    if(row < grid.length - 1)\n        neighbors.push(grid[row + 1][col])\n    // Gets the Left Cell\n    if(col > 0)\n        neighbors.push(grid[row][col - 1]);\n    // Gets the Right Cell\n    if(col < grid[0].length - 1)\n        neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nexport function getShortestPath(end) {\n    const pathOrder = [];\n    let currentCell = end;\n    if(currentCell.previous === null){\n    } else {\n        while(currentCell !== null) {\n            pathOrder.unshift(currentCell);\n            currentCell = currentCell.previous;\n        } \n    }\n    return pathOrder;\n}\n\n\nfunction getStart(grid) {\n    var start;\n    for(var col = 0; col < grid.length; col++){\n        for(var row = 0; row < grid[0].length; row++){\n            if(grid[col][row].startCell === true){\n                start = grid[col][row];\n            }\n        }\n    }\n    return start;\n}","\nexport function astar(grid, start, end){\n    var open = []\n    var closed = []\n    start = addNeighbors(start, grid, grid.length, grid[0].length)\n    start.f = start.g = start.h = 0;\n    open.push(start);\n    while(open.length > 0) {\n        var current = getSmallestElementInList(open);\n\n        if(current === end){\n            var curr = current;\n            var ret = []\n            while(curr.parent) {\n                ret.push(curr);\n                curr = curr.parent;\n            }\n            ret.push(curr);\n            return ret.reverse();\n        }\n\n        closed.push(current);\n        open = removeFromList(open, current);\n        current = addNeighbors(current, grid, grid.length, grid[0].length)\n        var neighbors = current.neighbors\n\n        for(var i = 0; i < neighbors.length; i++){\n            var neighbor = neighbors[i];\n            if(closed.includes(neighbor) || neighbor.wall === true)\n                continue;\n\n            var gScore = current.g + 1;\n            var gScoreIsBest = false;\n\n            if(!open.includes(neighbor)){\n                gScoreIsBest = true;\n                neighbor.h = heuristic(neighbor, end);\n                open.push(neighbor);\n            } else if(gScore < neighbor.g) {\n                gScoreIsBest = true;\n            }\n\n            if(gScoreIsBest === true) {\n                neighbor.parent = current;\n                neighbor.g = gScore;\n                neighbor.f = neighbor.g + neighbor.h;\n            }\n        }\n    }\n    return []\n}\n\nfunction getSmallestElementInList(list) {\n    var lowest = Number.MAX_SAFE_INTEGER;\n    for(var i = 0; i < list.length; i++){\n        if(list[i].f < lowest){\n            lowest = list[i];\n        }\n    }\n    return lowest;\n}\n\nfunction removeFromList(list, element) {\n    for(var i = list.length - 1; i >= 0; i--){\n        if(list[i] === element){\n            list.splice(i, 1);\n        }\n    }\n    return list\n}\n\nfunction addNeighbors(current, grid, cols, rows) {\n    var col = current.col;\n    var row = current.row;\n    var neighborsArray = [];\n    if(col < cols - 1){\n        neighborsArray.push(grid[col + 1][row])\n    }\n    if(col > 0){\n        neighborsArray.push(grid[col - 1][row])\n    }\n    if(row < rows - 1){\n        neighborsArray.push(grid[col][row + 1])\n    }\n    if(row > 0){\n        neighborsArray.push(grid[col][row - 1])\n    }\n    current.neighbors = neighborsArray;\n    return current;\n}\n\nfunction heuristic(a, b) {\n    var d1 = Math.pow(b.col - a.col, 2) + (Math.pow(b.row - a.row, 2))\n    var d2 = Math.pow(b.col - a.col, 2) + (Math.pow(b.row - a.row, 2))\n    return Math.sqrt(d1 + d2);\n}\n","// Height === Rows\n// Width === Columns\n\nexport function recursiveDivisionMaze(height, width){\n    // Starting Height and Width should be 1 and Ending Height and Width should be -1 to account for the border\n    var visited = recursiveDivision(1, width - 1, 1, height - 1);\n\n    return visited;\n}\n\n// maxCol = 30\n// maxRow = 15\nexport function recursiveDivision(minRows, maxRows, minCols, maxCols){ \n    var visited = [];\n    var orientation;\n    var windowWidth = maxRows - minRows;\n    var windowHeight = maxCols - minCols;\n    console.log(windowWidth, windowHeight)\n    windowWidth > windowHeight ? orientation = 'vertical' : orientation = 'horizontal';\n    console.log(orientation)\n\n    if(minCols > maxCols|| minRows > maxRows){\n        return visited;\n    }\n\n    if(windowWidth <= 2 || windowHeight <= 2){\n        return visited;\n    }\n\n\n    if(orientation === 'vertical'){\n        console.log(\"Bisecting Vertically!\")\n        var possibleWalls = [];\n        var possibleOpenings = [];\n        var randomColumn;\n        var randomRow;\n        // Add all height values to the list of possible walls\n        for(var a = minRows; a < maxRows; a++){\n            possibleWalls.push(a);\n        }\n\n        // Add all width values to the list of possible openings\n        for(var a = minCols; a < maxCols; a++){\n            possibleOpenings.push(a);\n        }\n\n        console.log(\"MAX ROWS: \" + maxRows)\n        console.log(\"MAX COLUMNS: \" + maxCols)\n        console.log(possibleOpenings.length)\n\n        randomColumn = Math.floor(Math.random() * (possibleOpenings.length - minRows) + minRows);\n        randomRow = Math.floor(Math.random() * (possibleWalls.length - minCols) + minCols);\n        \n        console.log(minRows, randomRow, maxRows)\n        console.log(minCols, randomColumn, maxCols)\n\n        for(var a = minRows; a <= maxRows; a++){\n            if(a === randomRow) { continue };\n            visited.push({\n                row: randomColumn,\n                col: a,\n                wall: true\n            })\n        }\n        // console.log(`Vertical Bisection Recursive Left Values MinCol: ${minCols} and MaxCol: ${randomColumn - 1}`)\n        // visited = visited.concat(recursiveDivision(minRows, maxRows, minCols, randomColumn - 1));\n        // console.log(`Vertical Bisection Recursive Right Values MinCol: ${randomColumn + 1} and MaxCol: ${maxCols}`)\n        // visited = visited.concat(recursiveDivision(minRows, maxRows, randomColumn + 1, maxCols));\n\n\n    } else {\n\n        console.log(\"Bisecting Horizontally!\")\n        var possibleWalls = [];\n        var possibleOpenings = [];\n        var randomColumn;\n        var randomRow;\n        // Add all height values to the list of possible walls\n\n        for(var a = minRows; a < maxRows; a++){\n            possibleOpenings.push(a);\n        }\n\n        // Add all width values to the list of possible openings\n        for(var a = minCols; a < maxCols; a++){\n            possibleWalls.push(a);\n        }\n\n        console.log(\"MAX ROWS: \" + maxRows)\n        console.log(\"MAX COLUMNS: \" + maxCols)\n        console.log(possibleOpenings.length)\n\n        randomRow = Math.floor(Math.random() * (possibleOpenings.length - minRows) + minRows);\n        randomColumn = Math.floor(Math.random() * (possibleWalls.length - minCols) + minCols);\n        \n        console.log(minRows, randomRow, maxRows)\n        console.log(minCols, randomColumn, maxCols)\n\n        for(var a = minCols; a <= maxCols; a++){\n            if(a === randomColumn) { continue };\n            visited.push({\n                row: a,\n                col: randomRow,\n                wall: true\n            })\n        }\n        // console.log(`Horizontal Bisection Recursive Left Values MinRow: ${minRows} and maxRows: ${randomRow - 1}`)\n        // visited = visited.concat(recursiveDivision(minRows, randomRow - 1, minCols, maxCols));\n\n        // console.log(`Horizontal Bisection Recursive Right Values MinRow: ${randomRow + 1} and MaxRow: ${maxRows}`)\n        // visited = visited.concat(recursiveDivision(randomRow + 1, maxRows, minCols, maxCols));\n\n\n\n\n    }\n    return visited;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export function recursiveDivision(grid, minHeight, maxHeight, minWidth, maxWidth, orientation){\n\n//     var visited = []\n//     var orientation;\n//     var windowWidth = maxWidth - minWidth;\n//     var windowHeight = maxHeight - minHeight;\n\n//     if(windowWidth <= 3 || windowHeight <= 3){\n//         return visited;\n//     }\n\n//     // if(maxHeight <= minHeight || maxWidth <= minWidth){\n//     //     return visited;\n//     // }\n\n//     if(orientation === 'vertical'){\n//         console.log(\"Entering Vertical\");\n//         var possibleColumns = [];\n//         var openRows = [];\n//         var randomColumnIndex;\n//         var randomRowIndex;\n//         var selectedColumn;\n//         var selectedRow;\n\n//         for(var a = minWidth; a < maxWidth; a += 1){\n//             possibleColumns.push(a);\n//         }\n//         for(var b = minHeight; b < maxHeight; b += 1){\n//             openRows.push(b);\n//         }\n\n//         randomColumnIndex = Math.floor(Math.random() * possibleColumns.length);\n//         randomRowIndex = Math.floor(Math.random() * openRows.length);\n\n//         selectedColumn = possibleColumns[randomColumnIndex];\n//         selectedRow = openRows[randomRowIndex];\n\n\n//         console.log(`Vertical Split Split: selected Row at ${selectedRow} with Entrance at ${selectedColumn}`)\n//         console.log(`Widths/Cols ${minWidth} and ${maxWidth} and Heights/Rows ${minHeight} and ${maxHeight}`)\n//         for(var a = minHeight; a <= maxHeight; a++){\n//             if(a === selectedRow) { continue };\n//             visited.push({\n//                 row: a,\n//                 col: selectedColumn,\n//                 wall: true\n//             })\n//         }\n\n        \n//         // visited = visited.concat(recursiveDivision(grid, minWidth, selectedColumn - 2, minHeight, maxHeight));\n//         // visited = visited.concat(recursiveDivision(grid, selectedColumn + 2, maxWidth, minHeight, maxHeight));\n        \n\n//         if (maxHeight - minHeight > selectedColumn - 1 - minWidth) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - ${minHeight} > ${selectedColumn} - 1 - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, minWidth, selectedColumn - 1, 'horizontal'));\n//           } else {\n//             // console.log(`VERTICAL: ${maxHeight} - ${minHeight} < ${selectedColumn} - 1 - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, minWidth, selectedColumn - 1, orientation));\n//           }\n//           if (maxHeight - minHeight > maxWidth - (selectedColumn + 1)) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - ${minHeight} > ${maxWidth} - (${selectedColumn} + 1) `);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, selectedColumn + 1, maxWidth, 'horizontal'));\n//           } else {\n//             // console.log(`VERTICAL: ${maxHeight} - ${minHeight} < ${maxWidth} - (${selectedColumn} + 1) `);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, selectedColumn + 1, maxWidth, orientation));\n//         }\n\n//     } else {\n//         console.log(\"Entering Horizontal\");\n//         var possibleRows = [];\n//         var openColumns = [];\n//         var randomColumnIndex;\n//         var randomRowIndex;\n//         var selectedColumn;\n//         var selectedRow;\n\n//         for(var a = minHeight; a < maxHeight; a+=1){\n//             possibleRows.push(a);\n//         }\n\n//         for(var b = minWidth; b < maxWidth; b+=1){\n//             openColumns.push(b);\n//         }\n\n//         randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n//         randomColumnIndex = Math.floor(Math.random() * openColumns.length);\n\n//         selectedRow = possibleRows[randomRowIndex];\n//         selectedColumn = openColumns[randomColumnIndex]\n\n//         for(var a = minWidth; a <= maxWidth; a++){\n//             if(a === selectedColumn) { continue };\n//             visited.push({\n//                 row: selectedRow,\n//                 col: a,\n//                 wall: true\n//             })\n//         }\n\n//         // visited = visited.concat(recursiveDivision(grid, minWidth, maxWidth, minHeight, selectedRow - 2));\n//         // visited = visited.concat(recursiveDivision(grid, minWidth, maxWidth, selectedRow + 2, maxHeight));\n\n//         console.log(`Horizontal Split: selected Row at ${selectedRow} with Entrance at ${selectedColumn}`)\n//         console.log(`Widths/Cols ${minWidth} and ${maxWidth} and Heights/Rows ${minHeight} and ${maxHeight}`)\n//         if (selectedRow - 1 - minHeight > maxWidth - minWidth) {\n//             // console.log(`HORIZONTAL: ${selectedRow} - 1 - ${minHeight} > ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, selectedRow - 1, minWidth, maxWidth, orientation));\n//         } else {\n//             // console.log(`VERTICAL: ${selectedRow} - 1 - ${minHeight} < ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, selectedRow - 1, minWidth, maxWidth, 'vertical'));\n//         }\n//         if (maxHeight - (selectedRow + 1) > maxWidth - minWidth) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - (${selectedRow} + 1)  > ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, selectedRow + 1, maxHeight, minWidth, maxWidth, orientation));\n//         } else {\n//             // console.log(`VERTICAL: ${maxHeight} - (${selectedRow} + 1)  < ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, selectedRow + 1, maxHeight, minWidth, maxWidth, 'vertical'));\n//         }\n//     }\n\n//     return visited;\n// }\n\n// export function recursiveDivision(grid, minHeight, maxHeight, minWidth, maxWidth, orientation){\n\n//     var visited = []\n//     var orientation;\n//     var windowWidth = maxWidth - minWidth;\n//     var windowHeight = maxHeight - minHeight;\n\n//     if(windowWidth <= 3 || windowHeight <= 3){\n//         return visited;\n//     }\n\n//     // if(maxHeight <= minHeight || maxWidth <= minWidth){\n//     //     return visited;\n//     // }\n\n//     if(orientation === 'vertical'){\n//         console.log(\"Entering Vertical\");\n//         var possibleColumns = [];\n//         var openRows = [];\n//         var randomColumnIndex;\n//         var randomRowIndex;\n//         var selectedColumn;\n//         var selectedRow;\n\n//         for(var a = minWidth; a < maxWidth; a += 1){\n//             possibleColumns.push(a);\n//         }\n//         for(var b = minHeight; b < maxHeight; b += 1){\n//             openRows.push(b);\n//         }\n\n//         randomColumnIndex = Math.floor(Math.random() * possibleColumns.length);\n//         randomRowIndex = Math.floor(Math.random() * openRows.length);\n\n//         selectedColumn = possibleColumns[randomColumnIndex];\n//         selectedRow = openRows[randomRowIndex];\n\n\n//         console.log(`Vertical Split Split: selected Row at ${selectedRow} with Entrance at ${selectedColumn}`)\n//         console.log(`Widths/Cols ${minWidth} and ${maxWidth} and Heights/Rows ${minHeight} and ${maxHeight}`)\n//         for(var a = minHeight; a <= maxHeight; a++){\n//             if(a === selectedRow) { continue };\n//             visited.push({\n//                 row: a,\n//                 col: selectedColumn,\n//                 wall: true\n//             })\n//         }\n\n        \n//         // visited = visited.concat(recursiveDivision(grid, minWidth, selectedColumn - 2, minHeight, maxHeight));\n//         // visited = visited.concat(recursiveDivision(grid, selectedColumn + 2, maxWidth, minHeight, maxHeight));\n        \n\n//         if (maxHeight - minHeight > selectedColumn - 1 - minWidth) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - ${minHeight} > ${selectedColumn} - 1 - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, minWidth, selectedColumn - 1, 'horizontal'));\n//           } else {\n//             // console.log(`VERTICAL: ${maxHeight} - ${minHeight} < ${selectedColumn} - 1 - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, minWidth, selectedColumn - 1, orientation));\n//           }\n//           if (maxHeight - minHeight > maxWidth - (selectedColumn + 1)) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - ${minHeight} > ${maxWidth} - (${selectedColumn} + 1) `);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, selectedColumn + 1, maxWidth, 'horizontal'));\n//           } else {\n//             // console.log(`VERTICAL: ${maxHeight} - ${minHeight} < ${maxWidth} - (${selectedColumn} + 1) `);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, maxHeight, selectedColumn + 1, maxWidth, orientation));\n//         }\n\n//     } else {\n//         console.log(\"Entering Horizontal\");\n//         var possibleRows = [];\n//         var openColumns = [];\n//         var randomColumnIndex;\n//         var randomRowIndex;\n//         var selectedColumn;\n//         var selectedRow;\n\n//         for(var a = minHeight; a < maxHeight; a+=1){\n//             possibleRows.push(a);\n//         }\n\n//         for(var b = minWidth; b < maxWidth; b+=1){\n//             openColumns.push(b);\n//         }\n\n//         randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n//         randomColumnIndex = Math.floor(Math.random() * openColumns.length);\n\n//         selectedRow = possibleRows[randomRowIndex];\n//         selectedColumn = openColumns[randomColumnIndex]\n\n//         for(var a = minWidth; a <= maxWidth; a++){\n//             if(a === selectedColumn) { continue };\n//             visited.push({\n//                 row: selectedRow,\n//                 col: a,\n//                 wall: true\n//             })\n//         }\n\n//         // visited = visited.concat(recursiveDivision(grid, minWidth, maxWidth, minHeight, selectedRow - 2));\n//         // visited = visited.concat(recursiveDivision(grid, minWidth, maxWidth, selectedRow + 2, maxHeight));\n\n//         console.log(`Horizontal Split: selected Row at ${selectedRow} with Entrance at ${selectedColumn}`)\n//         console.log(`Widths/Cols ${minWidth} and ${maxWidth} and Heights/Rows ${minHeight} and ${maxHeight}`)\n//         if (selectedRow - 1 - minHeight > maxWidth - minWidth) {\n//             // console.log(`HORIZONTAL: ${selectedRow} - 1 - ${minHeight} > ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, selectedRow - 1, minWidth, maxWidth, orientation));\n//         } else {\n//             // console.log(`VERTICAL: ${selectedRow} - 1 - ${minHeight} < ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, minHeight, selectedRow - 1, minWidth, maxWidth, 'vertical'));\n//         }\n//         if (maxHeight - (selectedRow + 1) > maxWidth - minWidth) {\n//             // console.log(`HORIZONTAL: ${maxHeight} - (${selectedRow} + 1)  > ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, selectedRow + 1, maxHeight, minWidth, maxWidth, orientation));\n//         } else {\n//             // console.log(`VERTICAL: ${maxHeight} - (${selectedRow} + 1)  < ${maxWidth} - ${minWidth}`);\n//             visited = visited.concat(recursiveDivision(grid, selectedRow + 1, maxHeight, minWidth, maxWidth, 'vertical'));\n//         }\n//     }\n\n//     return visited;\n// }\n\n\n\n// if (randomRowIndex - 2 - minHeight > maxWidth - minWidth) {\n//     recursiveDivisionMaze(grid, minWidth, maxWidth, minHeight, randomRowIndex - 2);\n//   } else {\n//     recursiveDivisionMaze(grid, minWidth, maxWidth, minHeight, randomRowIndex - 2);\n//   }\n//   if (maxHeight - (randomRowIndex + 2) > maxWidth - minWidth) {\n//     recursiveDivisionMaze(grid, minWidth, maxWidth, randomRowIndex + 2, maxHeight, );\n//   } else {\n//     recursiveDivisionMaze(grid, minWidth, maxWidth, randomRowIndex + 2, maxHeight);\n//   }\n\n// height === rows;\n// width === cols;\n\n\n","export function recursiveDivisionRandomizerMaze(grid, height, width){\n    var visited = recursiveDivisionRandomizer(grid, 1, width - 2, 1, height - 2);\n    return visited;\n}\n\n\nexport function recursiveDivisionRandomizer(grid, minWidth, maxWidth, minHeight, maxHeight){\n\n    var visited = []\n    var orientation;\n    var windowWidth = maxWidth - minWidth;\n    var windowHeight = maxHeight - minHeight;\n    windowWidth > windowHeight ? orientation = 'vertical' : orientation = 'horizontal';\n\n    if(windowWidth <= 1 || windowHeight <= 1){\n        return visited;\n    }\n\n    if(orientation === 'vertical'){\n        var possibleColumns = [];\n        var openRows = [];\n        var randomColumnIndex;\n        var randomRowIndex;\n        var selectedColumn;\n        var selectedRow;\n\n        for(var a = minWidth + 1; a <= maxWidth; a += 1){\n            possibleColumns.push(a);\n        }\n        for(var b = minHeight + 1; b <= maxHeight + 1; b += 1){\n            openRows.push(b);\n        }\n        console.log(possibleColumns)\n        console.log(openRows)\n\n        randomColumnIndex = Math.floor(Math.floor(Math.random() * possibleColumns.length));\n        randomRowIndex = Math.floor(Math.floor(Math.random() * openRows.length));\n\n        selectedColumn = possibleColumns[randomColumnIndex];\n        selectedRow = openRows[randomRowIndex];\n\n\n        console.log(`Horizontal Split: selected Column at ${selectedRow} with Entrance at ${selectedColumn} with heights ${minHeight} and ${maxHeight}`)\n        for(var a = minHeight; a <= maxHeight; a+=1){\n            if(a === selectedRow) { continue };\n            visited.push({\n                row: a,\n                col: selectedColumn,\n                wall: true\n            })\n        }\n        \n        visited = visited.concat(recursiveDivisionRandomizer(grid, minWidth, selectedColumn - 1, minHeight, maxHeight));\n        visited = visited.concat(recursiveDivisionRandomizer(grid, selectedColumn + 1, maxWidth, minHeight, maxHeight));\n    } else {\n        var possibleRows = [];\n        var openColumns = [];\n        var randomColumnIndex;\n        var randomRowIndex;\n        var selectedColumn;\n        var selectedRow;\n\n        for(var a = minHeight + 1; a <= maxHeight; a += 1){\n            possibleRows.push(a);\n        }\n\n        for(var b = minWidth + 1; b <= maxWidth + 1; b += 1){\n            openColumns.push(b);\n        }\n\n        randomRowIndex = Math.floor(Math.floor(Math.random() * possibleRows.length));\n        randomColumnIndex = Math.floor(Math.floor(Math.random() * openColumns.length));\n\n        selectedRow = possibleRows[randomRowIndex];\n        selectedColumn = openColumns[randomColumnIndex]\n        console.log(`Vertical Split: selected Row at ${selectedRow} with Entrance at ${selectedColumn} with widths ${minWidth} and ${maxWidth}`)\n\n        for(var a = minWidth; a <= maxWidth; a+=1){\n            if(a === selectedColumn) { continue };\n            visited.push({\n                row: selectedRow,\n                col: a,\n                wall: true\n            })\n        }\n\n        visited = visited.concat(recursiveDivisionRandomizer(grid, minWidth, maxWidth, minHeight, selectedRow - 1));\n        visited = visited.concat(recursiveDivisionRandomizer(grid, minWidth, maxWidth, selectedRow + 1, maxHeight));\n\n    }\n\n    return visited;\n}","import './Pathfinding.css'\nimport 'antd/dist/antd.css';\n\nimport React, { Component } from 'react';\nimport Cell from './Cells/Cell'\n\nimport { wait } from '@testing-library/react';\nimport { NodeIndexOutlined, NodeExpandOutlined, ClearOutlined, SmileOutlined } from '@ant-design/icons';\nimport { Layout, Menu, Button, Divider, Typography, Modal } from 'antd';\nimport { dijkstra, getShortestPath } from './Algorithms/Dijkstra'\nimport { astar } from './Algorithms/AStar'\nimport { recursiveDivisionMaze } from './Mazes/RecusiveDivision'\nimport { recursiveDivisionRandomizerMaze } from './Mazes/RecursiveDivisionRandomizer'\nimport { smilyFaceMaze } from './Mazes/Patterns'\n\nconst { Text } = Typography;\nconst { SubMenu } = Menu;\nconst { Header, Footer, Sider, Content } = Layout;\n\nclass Pathfinding extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            startRow: 1,\n            startCol: 1,\n            endRow: 8, \n            endCol: 8,\n            previousStartRow: 1,\n            previousStartCol: 1,\n            previousEndRow: 8,\n            previousEndCol: 8,\n            mouseDown: false,\n            mouseUp: true,\n            mouseHold: false,\n            holdingStart: false,\n            holdingEnd: false,\n            maxCols: 45, //47\n            maxRows: 27,  //27\n            activeMaze: false,\n            activeAlgorithm: false,\n            pathFound: false,\n            simulationComplete: false,\n            collapsed: false,\n            selectedAlgorithm: \"\",\n            selectedMaze: \"\",\n            destroyingWall: false,\n            visibelModal: true\n        }\n        this.createGrid = this.createGrid.bind(this)\n    }\n\n    componentDidMount() {\n        const grid = this.createGrid();\n        this.setState({ grid: grid });\n    }\n\n    handleOk = e => {\n        this.setState({\n          visibelModal: false,\n        });\n    };\n\n    createGrid = () => {\n        const grid = [];\n        for (let col = 0; col < this.state.maxCols; col++){\n            const currentCol = [];\n            for (let row = 0; row < this.state.maxRows; row++){\n                currentCol.push(this.createCell(row, col));\n            }\n            grid.push(currentCol);\n        }\n        return grid;\n    }\n\n    createCell = (col, row) => {\n        return {\n            col, row, startCell: row === this.state.startRow && col === this.state.startCol, endCell: row === this.state.endRow && col === this.state.endCol, distance: Infinity, wall: false, visited: false,\n            previous: null, neighbors: []\n        }\n    }\n\n    createWall = (grid, col, row) => {\n        const newGrid = grid.slice();\n        const cell = this.getCell(newGrid, col, row);\n        const newCell = {\n            ...cell,\n            wall: !cell.wall\n        };\n        newGrid[col][row] = newCell;\n        return newGrid;\n    }\n\n    getCell = (grid, col, row) => {\n        const cell = grid[col][row];\n        return cell;\n    }\n\n    setWall = (grid, walls) => {\n        var x = 0; \n        while(x < walls.length){\n            for(var col = 0; col < this.state.maxCols; col++){\n                for(var row = 0; row < this.state.maxRows; row++){\n                    if(walls[x].row === grid[col][row] && walls[x].col === grid[col][row] ){\n                        grid[col][row].wall = true;\n                    }\n                }\n            }\n            x++;\n        }\n        return grid;\n    }\n\n    handleMouseDown(col, row) {\n        const { grid, startCell, startRow, startCol, endRow, endCol, previousStartCol, previousStartRow } = this.state;\n        var current = this.getCell(grid, col, row);\n        if(current.col === startCol && current.row === startRow) {\n            this.setState({ holdingStart: true }) //, previousStartCol: col, previousStartRow: row \n        } else if(current.col === endCol && current.row === endRow) {\n            this.setState({ holdingEnd: true }) // previousEndCol: col, previousEndRow: row\n        } else if(current.wall === false) {\n            // document.getElementById(`cell-${current.col}-${current.row}`).className=\"cell cell-wall\";\n            document.getElementById(`cell-${current.col}-${current.row}`).classList.add('cell-wall');\n            current.wall = true;\n        } else if(current.wall === true) {\n            // document.getElementById(`cell-${current.col}-${current.row}`).className=\"cell cell-wall\";\n            document.getElementById(`cell-${current.col}-${current.row}`).classList.remove('cell-wall');\n            current.wall = false;\n            this.setState({ destroyingWall: true })\n        }\n        this.setState({ mouseDown: true, mouseUp: false })\n        \n    }\n\n    handleMouseEnter(col, row) {\n        const { grid, mouseDown, holdingStart, holdingEnd, startCol, startRow, endRow, endCol, destroyingWall, previousEndCol, previousEndRow, previousStartCol, previousStartRow } = this.state;\n        var current = this.getCell(grid, col, row);\n\n\n        if(mouseDown === true && holdingStart === true) {\n            document.getElementById(`cell-${this.state.startCol}-${this.state.startRow}`).classList.remove('cell-start');\n            this.setState({ startRow: current.row, startCol: current.col })\n            this.setState({ previousStartCol: startCol, previousStartRow: startRow })\n            document.getElementById(`cell-${current.col}-${current.row}`).classList.add('cell-start');\n\n\n\n        }else if(mouseDown === true && holdingEnd === true){\n            document.getElementById(`cell-${this.state.endCol}-${this.state.endRow}`).classList.remove('cell-end');\n            this.setState({ endRow: current.row, endCol: current.col })\n            this.setState({ previousEndCol: endCol, previousEndRow: endRow })\n            document.getElementById(`cell-${current.col}-${current.row}`).classList.add('cell-end');\n\n\n        } else if(mouseDown === true) {\n            if(current.col === startCol && current.row === startRow) {\n            } else if(current.col === endCol && current.row === endRow) {\n            } else if(destroyingWall === true){\n                if(current.wall === true) {\n                    document.getElementById(`cell-${current.col}-${current.row}`).classList.remove('cell-wall');\n                    current.wall = false;\n                }\n            } else {\n                document.getElementById(`cell-${current.col}-${current.row}`).className=\"cell cell-wall\";\n                current.wall = true;\n            }\n        }\n        \n    }\n    \n    // When the mouse click has been released, it will set the \"MOUSE PRESS\" state back to its default\n    handleMouseUp(col, row) {\n        const { grid, mouseDown, holdingStart, holdingEnd, previousStartCol, previousStartRow, startCol, startRow, destroyingWall } = this.state;\n        var current = this.getCell(grid, col, row)\n\n        if(holdingStart === true) {\n            this.setState({ startCol: row, startRow: col })\n        } else if(holdingEnd === true) {\n        } else if(mouseDown === true) {\n            if(current.startCell === true) {\n            } else if(current.endCell === true) {\n            } else if(destroyingWall === true){\n                document.getElementById(`cell-${current.col}-${current.row}`).classList.remove('cell-wall');\n                grid[col][row].wall = false;\n            } else {\n                document.getElementById(`cell-${current.col}-${current.row}`).className=\"cell cell-wall\";\n                grid[col][row].wall = true;\n            }\n        }\n        this.setState({ mouseDown: false, mouseUp: true, holdingEnd: false, holdingStart: false, destroyingWall: false })\n        this.updateGrid();\n    }\n    \n    handleClearBoard() {\n        const { grid, startCol, endCol, startRow, endRow } = this.state;\n        if(this.state.activeAlgorithm === false || this.state.activeMaze === false) {\n            var newGrid = [];\n            for(var col = 0; col < this.state.maxCols; col++){\n                var currentCol = []\n                for(var row = 0; row < this.state.maxRows; row++){\n                    var cell = this.getCell(this.state.grid, col, row);\n                    cell.wall = false;\n                    cell.visited = false;\n                    cell.startCell = false;\n                    cell.endCell = false;\n                    document.getElementById(`cell-${cell.col}-${cell.row}`).className=\"cell \";\n                    if(cell.col === startCol && cell.row === startRow){\n                        cell.startCell = true;\n                        document.getElementById(`cell-${cell.col}-${cell.row}`).className=\"cell cell-start\";\n                    } else if(cell.col === endCol && cell.row === endRow) {\n                        cell.endCell = true;\n                        document.getElementById(`cell-${cell.col}-${cell.row}`).className=\"cell cell-end\";\n                    }\n                    currentCol.push(cell);\n                }\n                newGrid.push(currentCol);\n            }\n            this.setState({ grid: newGrid, mouseDown: false, mouseUp: true, holdingStart: false, holdingEnd: false, buildingWall: false, activeAlgorithm: false, activeMaze: false, selectedAlgorithm: \"\", selectedMaze: \"\", simulationComplete: false });\n        }\n    }\n\n    drawBorders(col, row){\n        // 20 10\n        var mazeWalls = []\n\n        // TOP BORDER        \n        for(var i = col - 1; i > 0; i--){\n            mazeWalls.push({\n                row: i,\n                col: 0,\n                wall: true\n            })\n        }\n\n        // LEFT BORDER        \n        for(var i = 0; i < row; i++){\n            mazeWalls.push({\n                row: 0,\n                col: i,\n                wall: true\n            })\n        }\n\n        // BOTTOM BORDER        \n        for(var i = 0; i < col; i++){\n            mazeWalls.push({\n                row: i,\n                col: row - 1,\n                wall: true\n            })\n        }\n\n        // RIGHT BORDER        \n        for(var i = row - 1; i >= 0; i--){\n            mazeWalls.push({\n                row: col - 1,\n                col: i,\n                wall: true\n            })\n        }\n        return mazeWalls;\n    }\n\n    updateGrid(){\n        const { grid } = this.state;\n        var newGrid = [];\n        for(var col = 0; col < this.state.maxCols; col++){\n            var currentCol = [];\n            for(var row = 0; row < this.state.maxRows; row++){\n                var cell = this.createCell(row, col);\n                if(grid[col][row].wall === true) {\n                    cell.wall = true;\n                }\n                currentCol.push(cell);\n            }\n            newGrid.push(currentCol);\n        }\n\n        this.setState({ grid: newGrid })\n    }\n\n    // Switch case to vizualize multiple algorithms\n    visualizeAlgorithm(algorithm) {\n        // this.updateGrid();\n        const { grid, startRow, startCol, endRow, endCol } = this.state;\n        var start = grid[startRow][startCol];\n        var end = grid[endRow][endCol];\n        var visited = [];\n        var shortestPath;\n        switch(algorithm){\n            case 'Dijkstra':\n                visited = dijkstra(grid, start, end);\n                shortestPath = getShortestPath(end);\n                this.animateDijkstra(visited, shortestPath);\n                break;\n            case 'AStar':\n                visited = astar(grid, start, end);\n                this.animateShortestPath(visited);\n                break;\n            default:\n                console.log(\"Algorithm Not Found\");\n                break;\n        }\n    }    \n    \n    visualizeMaze(maze) {\n        const { grid, maxRows, maxCols } = this.state;\n        const visited = this.drawBorders(maxCols, maxRows);\n        var newVisited;\n        var newGrid = [];\n        switch(maze){\n            case 'Recursive Division':\n                newVisited = recursiveDivisionMaze(maxCols, maxRows);\n                break;\n            case \"Recursive Division Random\":\n                newVisited = recursiveDivisionRandomizerMaze(grid, maxRows, maxCols);\n                break;\n            case 'Smily':\n                newVisited = smilyFaceMaze(grid);\n                break;\n            default:\n                console.log(\"Maze Not Found\");\n        }\n        // var waitTime = \n        var waitTime = this.animateMaze(visited.concat(newVisited));\n        setTimeout(() => {\n            newGrid = this.setWall(grid, visited.concat(newVisited));\n            this.setState({ grid: newGrid })\n            this.setState({ activeMaze: false })\n        }, 10 * waitTime);\n\n    }\n\n    // Animates every \"CELL\" that is apart of the shortest path.\n    // Also re-animates the start and end\n    animateShortestPath(shortestPath) {\n        for (let i = 0; i < shortestPath.length; i++){\n            setTimeout(() => {\n                const cell = shortestPath[i];\n                document.getElementById(`cell-${cell.col}-${cell.row}`).classList.add('cell-shortest-path');\n            }, 50 * i);\n        }\n        var endCell = shortestPath[shortestPath.length - 1];\n        if(endCell !== undefined){ \n            this.setState({ pathFound: true });\n        }\n        this.setState({ simulationComplete: true, activeAlgorithm: false })\n    }\n\n    // Animates all every \"CELL\" that is not apart of the shortest path, the start, or the end\n    animateDijkstra(visited, shortestPath) {\n        for (let i = 0; i <= visited.length; i++){\n            if(i === visited.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(shortestPath);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const cell = visited[i];\n                document.getElementById(`cell-${cell.col}-${cell.row}`).classList.add('cell-visited');\n            }, 10 * i);\n        }\n        \n        \n    }\n\n    animateMaze(visited) {\n        for(var i = 0; i < visited.length - 1; i++){\n            const cell = visited[i];\n            if(cell.wall === true){\n                setTimeout(() => {\n                    document.getElementById(`cell-${cell.col}-${cell.row}`).classList.add('cell-wall');\n                }, 10 * i);\n            }\n        }\n        return i;\n    }\n\n    onCollapse = collapsed => {\n        this.setState({ collapsed });\n    };\n\n    render() { \n        const { grid } = this.state;\n        return ( \n\n            <React.Fragment>\n                <Modal\n                    title=\"Welcome to the Pathfinding Visualizer!\"\n                    visible={this.state.visibelModal}\n                    onOk={this.handleOk}\n                    onCancel={this.handleOk}\n                >\n                    <p>It is the MVP of this visualizer, so try it out! I plan to incorporate more features and algorithms in the future.</p>\n                    <p>Simply drag and drop the starting and ending nodes, select the algorithm on the left, and click \"Simulate\"! \n                        You can also draw on the canvas to create and destroy obstructions!</p>\n                </Modal>\n                 <Layout style={{ minHeight: '100vh' }}>\n                    {/* <Header> <h1 className=\"site-header\">PATHFINDING VISUALIZER</h1></Header> */}\n                    <Layout>\n                        <Sider width={\"15vw\"} collapsible collapsed={this.state.collapsed} onCollapse={this.onCollapse}>\n                            <Menu theme=\"dark\" defaultSelectedKeys={['1']} mode=\"inline\" defaultSelectedKeys={[]}>\n                                {/* <SubMenu key=\"sub1\" title={<React.Fragment> <NodeIndexOutlined /> <span> Pathfinding </span></React.Fragment>}> */}\n                                    <Divider type=\"horizontal\" />\n                                    <Menu.Item key=\"1\" onClick={() => this.setState({ selectedAlgorithm: 'Dijkstra' })}> Dijkstra </Menu.Item>\n                                    {/* <Menu.Item key=\"2\" onClick={() => this.setState({ selectedAlgorithm: 'AStar' })}> A* </Menu.Item>\n                                    <Menu.Item key=\"3\"> Other</Menu.Item> */}\n                                    <Divider type=\"horizontal\" />\n                                {/* </SubMenu> */}\n                                {/* <SubMenu key=\"sub2\" title={<React.Fragment> <NodeExpandOutlined /> <span> Maze </span> </React.Fragment>}>\n                                    <Menu.Item key=\"4\" onClick={() => this.setState({ selectedMaze: 'Recursive Division' })}> Recursive Division </Menu.Item>\n                                    <Menu.Item key=\"5\" onClick={() => this.setState({ selectedMaze: 'Recursive Backtracking' })}> Recursive Backtracking </Menu.Item>\n                                        <SubMenu key=\"sub3\" title={<React.Fragment> <SmileOutlined /> <span> Randomize </span> </React.Fragment>}>\n                                        <Menu.Item key=\"6\" onClick={() => this.setState({ selectedMaze: 'Smily' })}> Smily Face </Menu.Item>\n                                        <Menu.Item key=\"7\" onClick={() => this.setState({ selectedMaze: 'Recursive Backtracking' })}> Recursive Backtracking </Menu.Item>\n                                    </SubMenu>\n                                </SubMenu> \n                                <Divider type=\"horizontal\" /> */}\n\n                                <Menu.Item key=\"8\" \n                                    disabled={this.state.selectedAlgorithm === \"\" || this.state.activeAlgorithm === true || this.state.activeMaze === true } onClick={() => { this.setState({ activeAlgorithm: true}); this.visualizeAlgorithm(this.state.selectedAlgorithm)}}>\n                                    <ClearOutlined /> <span> {this.state.selectedAlgorithm === \"\" ? \"Choose an Algorithm\" : `Simulate ${this.state.selectedAlgorithm}` } </span>\n                                </Menu.Item>\n\n                                {/* <Menu.Item key=\"9\" \n                                    disabled={this.state.selectedMaze === \"\" || this.state.activeMaze === true} onClick={() => { this.setState({ activeMaze: true }); this.visualizeMaze(this.state.selectedMaze) }}>\n                                    <ClearOutlined /> <span> {this.state.selectedMaze === \"\" ? \"Choose an Maze\" : `Simulate ${this.state.selectedMaze}` } </span>\n                                </Menu.Item> */}\n\n                                <Menu.Item key=\"10\" \n                                    disabled={this.state.activeAlgorithm === true || this.state.activeMaze === true} onClick={() => {this.handleClearBoard() }}><ClearOutlined /> <span> Reset </span>\n                                </Menu.Item>\n\n                                <Divider type=\"horizontal\" />\n                            </Menu>\n                        </Sider>\n                        <Content style={{ paddingTop: \"10px\"}}>\n                            <div className=\"grid\" style={{ display: \"inline\"}}>\n                                {grid.map((row, rowId) => {\n                                    return (\n                                            <div key={rowId} className={\"col\"}>\n                                            {row.map((cell, cellId) => {\n                                                const { row, col, startCell, endCell, wall, visited, mouseDown } = cell;\n                                                return (\n                                                    <Cell \n                                                        key={cellId}\n                                                        row={col}\n                                                        col={row}\n                                                        startCell={startCell}\n                                                        endCell={endCell}\n                                                        wall={wall}\n                                                        visited={visited}\n                                                        mouseDown={mouseDown}\n                                                        onMouseDown={(col, row) => this.handleMouseDown(col, row)}\n                                                        onMouseEnter={(col, row) => this.handleMouseEnter(col, row)}\n                                                        onMouseUp={(col, row) => this.handleMouseUp(col, row)}\n                                                    />\n                                                );\n                                            })}\n                                        </div>\n                                    );\n                                })}\n                            </div>\n                        </Content>\n                    </Layout>\n                </Layout>\n                \n                \n\n            </React.Fragment>\n         );\n    }\n}\n\nexport default Pathfinding;\n\n\n\n","export function smilyFaceMaze(grid){\n    var visited = []\n    var current = grid[10][10];\n    current.wall = true;\n    visited.push(current)\n    // for(var x = 16; x <=19; x++){\n\n    //     grid[x][4].wall = true;\n    //     grid[x][5].wall = true;\n    //     grid[x][6].wall = true;\n    //     grid[x][7].wall = true;\n    //     grid[x][18].wall = true;\n    //     grid[x][19].wall = true;\n    //     grid[x][20].wall = true;\n    //     grid[x][21].wall = true;\n\n    //     visited.push(grid[x][4])\n    //     visited.push(grid[x][5])\n    //     visited.push(grid[x][6])\n    //     visited.push(grid[x][7])\n    //     visited.push(grid[x][18])\n    //     visited.push(grid[x][19])\n    //     visited.push(grid[x][20])\n    //     visited.push(grid[x][21])\n    // }\n\n\n    // for(var x = 25; x <=28; x++){\n    //     visited.push(grid[x][4])\n    //     visited.push(grid[x][5])\n    //     visited.push(grid[x][6])\n    //     visited.push(grid[x][7])\n    //     visited.push(grid[x][18])\n    //     visited.push(grid[x][19])\n    //     visited.push(grid[x][20])\n    //     visited.push(grid[x][21])\n    // }\n\n    // for(var x = 20; x <= 25; x++){\n    //     visited.push(grid[x][20])\n    //     visited.push(grid[x][21])\n    //     visited.push(grid[x][22])\n    // }\n    console.log(visited);\n    return visited;\n}","export function createDisplay(length) {\n    var display = []\n    for (var index = 0; index < length.length; index++){\n            display.push(length[index]);\n    }\n    return display;\n}\n\nexport function handlePush(stack, index) {\n    var selected = getNode(stack, index - 1)\n    document.getElementById(`node-${index}`).classList.add('node-current');\n    // document.getElementById(`node-${index}`).classList.add('node-visited');\n    // animateGoingIntoStack(stack, index - 1)\n}\n\nexport function handlePop(stack, index) {\n    var selected = getNode(stack, index + 1);\n    document.getElementById(`node-${index+1}`).classList.remove('node-visited');\n}\n\nfunction getNode(stack, index) {\n    var selected = stack[index];\n    return selected;\n}","import React, { Component } from 'react'\nimport './Node.css'\n\nclass Node extends Component {\n    render() { \n        const { index, visited, letter, currentIndex, stackState } = this.props;\n        const classIdentifier = currentIndex === true ? 'node-current' : visited ? 'node-visited' : '';\n        return ( \n            <div className={`node ${classIdentifier} `} id={`node-${index}`} visited={visited}> \n                {classIdentifier === \"node-visited\" || classIdentifier === \"node-current\" ? letter : ''}\n            </div>\n        );\n    }\n}\n \nexport default Node;","import './DataStructures.css'\n\nimport React, { Component } from 'react';\nimport { createDisplay, handlePush, handlePop } from './Stack/Stack'\nimport Node from './Node/Node';\nimport { ClearOutlined, CloseOutlined, CheckOutlined } from '@ant-design/icons';\nimport { Layout, Menu, Button, Divider, Typography, Modal, Input, message, Switch } from 'antd';\n\nconst { Text } = Typography;\nconst { SubMenu } = Menu;\nconst { Header, Footer, Sider, Content } = Layout;\nconst { Search } = Input;\n\nclass Pathfinding extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            selectedStructure: \"\",\n            activeStructure: false,\n            value: \"\", \n            arr: [],\n            originalString: \"\",\n            reversedString: \"\",\n            pushedStack: \"\",\n            currentIndex: 0,\n            active: false\n\n        }\n    }\n\n    componentDidMount() {\n        \n    }\n\n\n\n    computeEquation(string) {\n        if(string.length <= 25) {\n            var arr = createDisplay(string);\n            this.setState({ value: string, arr: arr.reverse(), currentIndex: arr.length, originalString: string, active: true })    \n        } else {\n            message.warning('Your submission must be less than 26 characters');\n        }\n    }\n\n    pushIndex(index) {\n        const { arr, pushedStack, originalString, reversedString } = this.state;\n        handlePush(arr, index);\n        var newString = originalString.substring(1);\n        var newPushed = pushedStack.concat(originalString[0])\n        var newReversed = reversedString.substring(0)\n        this.setState({ currentIndex: index - 1, originalString: newString, pushedStack: newPushed, reversedString: newReversed })\n    }\n\n    popIndex(index) {\n        const { arr, pushedStack, originalString, reversedString } = this.state;\n        handlePop(arr, index);\n        var newPushed = pushedStack.substring(0, pushedStack.length - 1)\n        var newString = arr[index] + originalString;\n        var newReversed = reversedString.concat(arr[index]);\n        this.setState({ currentIndex: index + 1, originalString: newString, pushedStack: newPushed, reversedString: newReversed }) \n    }\n\n    clearStack() {\n        var val = this.state.value;\n        this.setState({ arr: [], active: false, pushedStack: [] , originalString: val, reversedString: \"\" })\n    }\n\n    render() { \n        const { value, arr, originalString, currentIndex } = this.state;\n        return ( \n\n            <React.Fragment>\n                <Modal\n                    title=\"Welcome to the Data Structure Visualizer!\"\n                    visible={this.state.visibelModal}\n                    onOk={this.handleOk}\n                    onCancel={this.handleOk}\n                >\n                    <p>It is the MVP of this visualizer, so try it out! I plan to incorporate more features and algorithms in the future.</p>\n                    <p>Simply drag and drop the starting and ending nodes, select the algorithm on the left, and click \"Simulate\"! \n                        You can also draw on the canvas to create and destroy obstructions!</p>\n                </Modal>\n                 <Layout style={{ minHeight: '100vh' }}>\n                    <Layout>\n                        <Sider width={\"15vw\"} collapsible collapsed={this.state.collapsed} onCollapse={this.onCollapse}>\n                            <Menu theme=\"dark\" defaultSelectedKeys={['1']} mode=\"inline\" defaultSelectedKeys={[]}>\n                                    <Divider type=\"horizontal\" />\n                                    <Menu.Item key=\"1\" onClick={() => this.setState({ selectedAlgorithm: 'Dijkstra' })}> Stacks </Menu.Item>\n                                    <Menu.Item key=\"2\" onClick={() => this.setState({ selectedAlgorithm: 'Dijkstra' })}> Queues </Menu.Item>\n                                    <Divider type=\"horizontal\" />\n                                <Menu.Item key=\"8\" \n                                    disabled={this.state.selectedAlgorithm === \"\" || this.state.activeAlgorithm === true || this.state.activeMaze === true } onClick={() => { this.setState({ activeAlgorithm: true}); this.visualizeAlgorithm(this.state.selectedAlgorithm)}}>\n                                    <ClearOutlined /> <span> {this.state.selectedAlgorithm === \"\" ? \"Choose an Algorithm\" : `Simulate ${this.state.selectedAlgorithm}` } </span>\n                                </Menu.Item>\n\n                                <Menu.Item key=\"10\" \n                                    disabled={this.state.activeAlgorithm === true || this.state.activeMaze === true} onClick={() => {this.handleClearBoard() }}><ClearOutlined /> <span> Reset </span>\n                                </Menu.Item>\n\n                                <Divider type=\"horizontal\" />\n                            </Menu>\n                        </Sider>\n                        <Content style={{ paddingTop: \"10px\"}} className=\"content\">\n                            \n                            <div className=\"information\">\n                                <div style={{}}>\n                                    <h1>Stack Contains: </h1>\n                                    {this.state.pushedStack.length > 0 ? this.state.pushedStack : ''}\n                                </div>\n                                <div style={{paddingLeft: \"20px\"}}>\n                                    <h1>Original String: </h1>\n                                    {this.state.originalString.length > 0 ? this.state.originalString : ''}\n                                </div>\n                                {/* <div style={{paddingLeft: \"20px\"}}>\n                                    <h1>Reversed String: </h1>\n                                    {this.state.reversedString.length > 0 ? this.state.reversedString : ''}\n                                </div> */}\n                            </div>\n\n\n                            <div className=\"stack\">\n                                {arr.map((index, indexId) => {\n                                    return (\n                                        <Node index={indexId + 1} visited={indexId >= currentIndex ? true : false} currentIndex={indexId === this.state.currentIndex} letter={index}/>\n                                    )\n                                })}\n                            </div>\n\n                            <div className=\"user-input\">\n                                <Search placeholder=\"Enter Valid Equation\" enterButton=\"Visualize Stack\" onSearch={(value) => this.computeEquation(value)} style={{ width: \"300px\"}}/>\n                                <Divider type=\"vertical\" />\n                                <Button onClick={() => this.pushIndex( this.state.currentIndex )} disabled={(this.state.currentIndex === 0 ? true : false) || (this.state.active === false)}> Push </Button>\n                                <Button onClick={() => this.popIndex( this.state.currentIndex )} disabled={(this.state.currentIndex === value.length ? true : false) || (this.state.active === false)}> Pop </Button>\n                                <Button onClick={() => this.clearStack( )} disabled={this.state.arr.length === 0}> Clear Stack </Button>\n                                {/* <Switch checkedChildren={<CheckOutlined />} unCheckedChildren={<CloseOutlined />} defaultChecked style={{ marginLeft: \"20px\"}}/> */}\n                            </div>\n                        </Content>\n                    </Layout>\n                </Layout>\n                \n                \n\n            </React.Fragment>\n         );\n    }\n}\n\nexport default Pathfinding;\n\n\n\n","export function mergeSortAlgo(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    preMergeSort(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n  }\n  \n  function preMergeSort(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n    if (startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    preMergeSort(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    preMergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    mergeSort(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n  }\n  \n  function mergeSort(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n      animations.push([i, j]);\n      animations.push([i, j]);\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n        animations.push([k, auxiliaryArray[i]]);\n        mainArray[k++] = auxiliaryArray[i++];\n      } else {\n        animations.push([k, auxiliaryArray[j]]);\n        mainArray[k++] = auxiliaryArray[j++];\n      }\n    }\n    while (i <= middleIdx) {\n      animations.push([i, i]);\n      animations.push([i, i]);\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n      animations.push([j, j]);\n      animations.push([j, j]);\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }","export function quickSortAlgo(array) {\n    const animations = [];\n    if(array.length <= 1) return array;\n    const auxArray = array.slice();\n    quickSort(auxArray, 0, auxArray.length - 1, animations);\n    console.log(auxArray)\n    return animations;\n}\n\nfunction quickSort(arr, low, high, animations) {\n    if(low < high) {\n        var index = partition(arr, low, high, animations);\n        quickSort(arr, low, index - 1, animations);\n        quickSort(arr, index + 1, high, animations);\n    }\n\n}\n\nfunction partition(arr, low, high, animations) {\n    var pivot = arr[high];\n    var i = (low - 1);\n\n    for(var j = low; j <= high - 1; j++) {\n        if(arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i+1, high);\n    animations.push([i, arr[j]])\n    return i+1;\n\n}\n\n\nfunction swap(arr, a, b) {\n    var t = arr[a];\n    arr[a] = arr[b];\n    arr[b] = t;\n    return arr;\n}","import './Sorting.css'\nimport 'antd/dist/antd.css';\n\nimport React, { Component } from 'react';\nimport { ClearOutlined } from '@ant-design/icons';\nimport { Layout, Menu, Divider } from 'antd';\nimport { mergeSortAlgo } from './Algorithms/MergeSort';\nimport { quickSortAlgo } from './Algorithms/QuickSort';\n\nconst { SubMenu } = Menu;\nconst { Header, Sider, Content } = Layout;\n\n\nclass Sorting extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            arr: [],\n            selectedSort: \"\",\n        }\n    }\n\n\n    componentDidMount() {\n        this.clearArray();\n    }\n\n    clearArray() {\n        var array = [];\n        for(var i = 0; i < 30; i++) {\n            array.push(randomIntFromInterval(5, 800))\n        }\n        this.setState({ arr: array })\n    }\n\n    computeSort() {\n        const { arr, selectedSort } = this.state;\n        var animations;\n        switch (selectedSort) {\n            case \"Merge\":\n                // this.computeMergeSort(arr);\n                animations = mergeSortAlgo(arr);\n                break;\n            case \"Quick\":\n                animations = quickSortAlgo(arr);\n                break;\n        }\n        this.animateSorting(animations);\n    }\n\n    // computeMergeSort() {\n    //     const { arr } = this.state;\n    //     const animations = mergeSortAlgo(arr);\n    //     this.animateSorting(animations);\n    // }\n\n    animateSorting(animations) {\n        for (let i = 0; i < animations.length; i++) {\n            const arrayBars = document.getElementsByClassName('bar');\n            const isColorChange = i % 3 !== 2;\n            if (isColorChange) {\n                const [barOneIdx, barTwoIdx] = animations[i];\n                console.log(barOneIdx, barTwoIdx);\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n                const color = i % 3 === 0 ? '#CA8677' : '#77BBCA';\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = color;\n                    barTwoStyle.backgroundColor = color;\n                }, i * 5);\n            } else {\n                setTimeout(() => {\n                    const [barOneIdx, newHeight] = animations[i];\n                    const barOneStyle = arrayBars[barOneIdx].style;\n                    barOneStyle.height = `${newHeight}px`;\n                }, i * 5);\n            }\n        }\n    }\n\n\n    onCollapse = collapsed => {\n        this.setState({ collapsed });\n    };\n\n\n    render() { \n        const { arr, selectedSort } = this.state;\n        return ( \n            <React.Fragment>\n                <Layout style={{ minHeight: '100vh' }}>\n                    <Layout>\n                        <Sider width={\"15vw\"} collapsible collapsed={this.state.collapsed} onCollapse={this.onCollapse}>\n                            <Menu theme=\"dark\" mode=\"inline\" defaultSelectedKeys={[]}>\n                                <Divider type=\"horizontal\" />\n                                <Menu.Item key=\"1\" onClick={() => this.setState({ selectedSort: \"Quick\" })}> <ClearOutlined /> <span> Quick Sort </span> </Menu.Item>\n                                <Menu.Item key=\"2\" onClick={() => this.setState({ selectedSort: \"Merge\" })}> <ClearOutlined /> <span> Merge Sort </span> </Menu.Item>\n                                <Menu.Item key=\"3\" onClick={() => this.setState({ selectedSort: \"Bubble\" })}> <ClearOutlined /> <span> Bubble Sort </span> </Menu.Item>\n                                <Menu.Item key=\"4\" onClick={() => this.computeSort()}>\n                                <ClearOutlined /> <span> Simulate </span> \n                                </Menu.Item>\n                                <Menu.Item key=\"5\" onClick={() => this.clearArray()}> <ClearOutlined /> <span> Reset </span> </Menu.Item>\n                                <Menu.Item key=\"5\" onClick={() => { console.log(arr) }}> <ClearOutlined /> <span> Print </span> </Menu.Item>\n                            </Menu>\n                        </Sider>\n                        <Content style={{ paddingTop: \"10px\"}}>\n                            <div className=\"container\">\n                                <h1> {selectedSort} </h1>\n                                {arr.map((value, index) => {\n                                    return (\n                                        <div className=\"bar\" key={index} style={{ height: `${value}px`}}>\n                                        </div>\n                                    )\n                                })}\n                            </div>\n                        </Content>\n                    </Layout>\n                </Layout>\n            </React.Fragment>\n         );\n    }\n}\n \nexport default Sorting;\n\n\n\nfunction randomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}","import './App.css';\nimport 'antd/dist/antd.css';\nimport React, { useParams } from 'react';\nimport Pathfinding from './Pathfinding/Pathfinding'\nimport DataStructures from './DataStrucutres/DataStructures'\nimport Sorting from './Sorting/Sorting'\nimport { Button, Menu } from 'antd'\nimport { BrowserRouter as Router, Switch, Route, Link } from \"react-router-dom\";\n\nfunction App() {\n  return (\n    <React.Fragment>\n      <Router>\n      <div className=\"App\">\n        <Menu mode=\"horizontal\" theme={\"dark\"}>\n          <Menu.Item>\n          <Link to=\"/\"><Button ghost> Home </Button></Link>\n          </Menu.Item>\n          <Menu.Item>\n          <Link to=\"/pathfinding\"><Button ghost> Pathfinding </Button></Link>\n          </Menu.Item>\n          <Menu.Item>\n          <Link to=\"/data-structures\"><Button ghost> Data Structures </Button></Link>\n          </Menu.Item>\n          <Menu.Item>\n          <Link to=\"/sorting\"><Button ghost> Sorting </Button></Link>\n          </Menu.Item>\n          <Menu.Item>\n          <Link to=\"/trees\"><Button ghost> Trees </Button></Link>\n          </Menu.Item>\n        </Menu>\n\n        <Switch>\n          <Route exact path=\"/\">\n            <h1> Hello </h1>\n          </Route>\n          <Route path=\"/pathfinding\">\n            <Pathfinding />\n          </Route>\n          <Route path=\"/data-structures\">\n            <DataStructures />\n          </Route>\n          <Route path=\"/sorting\">\n            <Sorting />\n          </Route>\n          <Route path=\"/trees\">\n            <h1> trees </h1>\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  </React.Fragment>\n  )\n}\n \nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { BrowserRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}